{"ast":null,"code":"'use client';\n\nimport { useState, useRef, useCallback } from 'react';\nimport isEqual from 'fast-deep-equal';\nimport { getStatus } from '../../get-status/get-status.mjs';\nimport { clearListState } from '../../lists/clear-list-state.mjs';\nimport { getPath } from '../../paths/get-path.mjs';\nimport 'klona/full';\nfunction useFormStatus({\n  initialDirty,\n  initialTouched,\n  mode,\n  $values\n}) {\n  const [touchedState, setTouchedState] = useState(initialTouched);\n  const [dirtyState, setDirtyState] = useState(initialDirty);\n  const touchedRef = useRef(initialTouched);\n  const dirtyRef = useRef(initialDirty);\n  const setTouched = useCallback(values => {\n    const resolvedValues = typeof values === \"function\" ? values(touchedRef.current) : values;\n    touchedRef.current = resolvedValues;\n    if (mode === \"controlled\") {\n      setTouchedState(resolvedValues);\n    }\n  }, []);\n  const setDirty = useCallback((values, forceUpdate = false) => {\n    const resolvedValues = typeof values === \"function\" ? values(dirtyRef.current) : values;\n    dirtyRef.current = resolvedValues;\n    if (mode === \"controlled\" || forceUpdate) {\n      setDirtyState(resolvedValues);\n    }\n  }, []);\n  const resetTouched = useCallback(() => setTouched({}), []);\n  const resetDirty = useCallback(values => {\n    const newSnapshot = values ? {\n      ...values,\n      ...$values.refValues.current\n    } : $values.refValues.current;\n    $values.setValuesSnapshot(newSnapshot);\n    setDirty({});\n  }, []);\n  const setFieldTouched = useCallback((path, touched) => {\n    setTouched(currentTouched => {\n      if (getStatus(currentTouched, path) === touched) {\n        return currentTouched;\n      }\n      return {\n        ...currentTouched,\n        [path]: touched\n      };\n    });\n  }, []);\n  const setFieldDirty = useCallback((path, dirty, forceUpdate) => {\n    setDirty(currentDirty => {\n      if (getStatus(currentDirty, path) === dirty) {\n        return currentDirty;\n      }\n      return {\n        ...currentDirty,\n        [path]: dirty\n      };\n    }, forceUpdate);\n  }, []);\n  const setCalculatedFieldDirty = useCallback((path, value) => {\n    const currentDirty = getStatus(dirtyRef.current, path);\n    const dirty = !isEqual(getPath(path, $values.getValuesSnapshot()), value);\n    const clearedState = clearListState(path, dirtyRef.current);\n    clearedState[path] = dirty;\n    setDirty(clearedState, currentDirty !== dirty);\n  }, []);\n  const isTouched = useCallback(path => getStatus(touchedRef.current, path), []);\n  const clearFieldDirty = useCallback(path => setDirty(current => {\n    if (typeof path !== \"string\") {\n      return current;\n    }\n    const result = clearListState(path, current);\n    delete result[path];\n    if (isEqual(result, current)) {\n      return current;\n    }\n    return result;\n  }), []);\n  const isDirty = useCallback(path => {\n    if (path) {\n      const overriddenValue = getPath(path, dirtyRef.current);\n      if (typeof overriddenValue === \"boolean\") {\n        return overriddenValue;\n      }\n      const sliceOfValues = getPath(path, $values.refValues.current);\n      const sliceOfInitialValues = getPath(path, $values.valuesSnapshot.current);\n      return !isEqual(sliceOfValues, sliceOfInitialValues);\n    }\n    const isOverridden = Object.keys(dirtyRef.current).length > 0;\n    if (isOverridden) {\n      return getStatus(dirtyRef.current);\n    }\n    return !isEqual($values.refValues.current, $values.valuesSnapshot.current);\n  }, []);\n  const getDirty = useCallback(() => dirtyRef.current, []);\n  const getTouched = useCallback(() => touchedRef.current, []);\n  return {\n    touchedState,\n    dirtyState,\n    touchedRef,\n    dirtyRef,\n    setTouched,\n    setDirty,\n    resetDirty,\n    resetTouched,\n    isTouched,\n    setFieldTouched,\n    setFieldDirty,\n    setTouchedState,\n    setDirtyState,\n    clearFieldDirty,\n    isDirty,\n    getDirty,\n    getTouched,\n    setCalculatedFieldDirty\n  };\n}\nexport { useFormStatus };","map":{"version":3,"names":["useFormStatus","initialDirty","initialTouched","mode","$values","touchedState","setTouchedState","useState","dirtyState","setDirtyState","touchedRef","useRef","dirtyRef","setTouched","useCallback","values","resolvedValues","current","setDirty","forceUpdate","resetTouched","resetDirty","newSnapshot","refValues","setValuesSnapshot","setFieldTouched","path","touched","currentTouched","getStatus","setFieldDirty","dirty","currentDirty","setCalculatedFieldDirty","value","isEqual","getPath","getValuesSnapshot","clearedState","clearListState","isTouched","clearFieldDirty","result","isDirty","overriddenValue","sliceOfValues","sliceOfInitialValues","valuesSnapshot","isOverridden","Object","keys","length","getDirty","getTouched"],"sources":["C:\\Users\\Christina\\Desktop\\React\\FED-medical\\node_modules\\@mantine\\form\\src\\hooks\\use-form-status\\use-form-status.ts"],"sourcesContent":["import { useCallback, useRef, useState } from 'react';\nimport isEqual from 'fast-deep-equal';\nimport { getStatus } from '../../get-status';\nimport { clearListState } from '../../lists';\nimport { getPath } from '../../paths';\nimport {\n  ClearFieldDirty,\n  FormMode,\n  FormStatus,\n  GetFieldStatus,\n  ResetDirty,\n  ResetStatus,\n  SetCalculatedFieldDirty,\n  SetFieldDirty,\n  SetFieldTouched,\n} from '../../types';\nimport type { $FormValues } from '../use-form-values/use-form-values';\n\nexport interface $FormStatus<Values extends Record<string, any>> {\n  touchedState: FormStatus;\n  dirtyState: FormStatus;\n  touchedRef: React.MutableRefObject<FormStatus>;\n  dirtyRef: React.MutableRefObject<FormStatus>;\n  setTouched: React.Dispatch<React.SetStateAction<FormStatus>>;\n  setDirty: React.Dispatch<React.SetStateAction<FormStatus>>;\n  resetDirty: ResetStatus;\n  resetTouched: ResetStatus;\n  isTouched: GetFieldStatus<Values>;\n  setFieldTouched: SetFieldTouched<Values>;\n  setFieldDirty: SetFieldDirty<Values>;\n  setTouchedState: React.Dispatch<React.SetStateAction<FormStatus>>;\n  setDirtyState: React.Dispatch<React.SetStateAction<FormStatus>>;\n  clearFieldDirty: ClearFieldDirty;\n  isDirty: GetFieldStatus<Values>;\n  getDirty: () => FormStatus;\n  getTouched: () => FormStatus;\n  setCalculatedFieldDirty: SetCalculatedFieldDirty<Values>;\n}\n\ninterface UseFormStatusInput<Values extends Record<string, any>> {\n  initialDirty: FormStatus;\n  initialTouched: FormStatus;\n  mode: FormMode;\n  $values: $FormValues<Values>;\n}\n\nexport function useFormStatus<Values extends Record<string, any>>({\n  initialDirty,\n  initialTouched,\n  mode,\n  $values,\n}: UseFormStatusInput<Values>): $FormStatus<Values> {\n  const [touchedState, setTouchedState] = useState(initialTouched);\n  const [dirtyState, setDirtyState] = useState(initialDirty);\n\n  const touchedRef = useRef(initialTouched);\n  const dirtyRef = useRef(initialDirty);\n\n  const setTouched = useCallback((values: FormStatus | ((current: FormStatus) => FormStatus)) => {\n    const resolvedValues = typeof values === 'function' ? values(touchedRef.current) : values;\n    touchedRef.current = resolvedValues;\n\n    if (mode === 'controlled') {\n      setTouchedState(resolvedValues);\n    }\n  }, []);\n\n  const setDirty = useCallback(\n    (values: FormStatus | ((current: FormStatus) => FormStatus), forceUpdate = false) => {\n      const resolvedValues = typeof values === 'function' ? values(dirtyRef.current) : values;\n      dirtyRef.current = resolvedValues;\n\n      if (mode === 'controlled' || forceUpdate) {\n        setDirtyState(resolvedValues);\n      }\n    },\n    []\n  );\n\n  const resetTouched: ResetStatus = useCallback(() => setTouched({}), []);\n\n  const resetDirty: ResetDirty<Values> = useCallback((values) => {\n    const newSnapshot = values\n      ? { ...values, ...$values.refValues.current }\n      : $values.refValues.current;\n    $values.setValuesSnapshot(newSnapshot);\n    setDirty({});\n  }, []);\n\n  const setFieldTouched: SetFieldTouched<Values> = useCallback((path, touched) => {\n    setTouched((currentTouched) => {\n      if (getStatus(currentTouched, path) === touched) {\n        return currentTouched;\n      }\n\n      return { ...currentTouched, [path]: touched };\n    });\n  }, []);\n\n  const setFieldDirty: SetFieldDirty<Values> = useCallback((path, dirty, forceUpdate) => {\n    setDirty((currentDirty) => {\n      if (getStatus(currentDirty, path) === dirty) {\n        return currentDirty;\n      }\n\n      return { ...currentDirty, [path]: dirty };\n    }, forceUpdate);\n  }, []);\n\n  const setCalculatedFieldDirty: SetCalculatedFieldDirty<Values> = useCallback((path, value) => {\n    const currentDirty = getStatus(dirtyRef.current, path);\n    const dirty = !isEqual(getPath(path, $values.getValuesSnapshot()), value);\n    const clearedState = clearListState(path, dirtyRef.current);\n    clearedState[path as string] = dirty;\n    setDirty(clearedState, currentDirty !== dirty);\n  }, []);\n\n  const isTouched: GetFieldStatus<Values> = useCallback(\n    (path) => getStatus(touchedRef.current, path),\n    []\n  );\n\n  const clearFieldDirty: ClearFieldDirty = useCallback(\n    (path) =>\n      setDirty((current) => {\n        if (typeof path !== 'string') {\n          return current;\n        }\n\n        const result = clearListState(path, current);\n        delete result[path];\n\n        if (isEqual(result, current)) {\n          return current;\n        }\n\n        return result;\n      }),\n    []\n  );\n\n  const isDirty: GetFieldStatus<Values> = useCallback((path) => {\n    if (path) {\n      const overriddenValue = getPath(path, dirtyRef.current);\n      if (typeof overriddenValue === 'boolean') {\n        return overriddenValue;\n      }\n\n      const sliceOfValues = getPath(path, $values.refValues.current);\n      const sliceOfInitialValues = getPath(path, $values.valuesSnapshot.current);\n      return !isEqual(sliceOfValues, sliceOfInitialValues);\n    }\n\n    const isOverridden = Object.keys(dirtyRef.current).length > 0;\n    if (isOverridden) {\n      return getStatus(dirtyRef.current);\n    }\n\n    return !isEqual($values.refValues.current, $values.valuesSnapshot.current);\n  }, []);\n\n  const getDirty = useCallback(() => dirtyRef.current, []);\n  const getTouched = useCallback(() => touchedRef.current, []);\n\n  return {\n    touchedState,\n    dirtyState,\n    touchedRef,\n    dirtyRef,\n    setTouched,\n    setDirty,\n    resetDirty,\n    resetTouched,\n    isTouched,\n    setFieldTouched,\n    setFieldDirty,\n    setTouchedState,\n    setDirtyState,\n    clearFieldDirty,\n    isDirty,\n    getDirty,\n    getTouched,\n    setCalculatedFieldDirty,\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}