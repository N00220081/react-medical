{"ast":null,"code":"'use client';\n\nimport { useState, useRef, useMemo, useCallback } from 'react';\nimport { getInputOnChange } from './get-input-on-change/get-input-on-change.mjs';\nimport 'klona/full';\nimport { shouldValidateOnChange } from './validate/should-validate-on-change.mjs';\nfunction useField({\n  mode = \"controlled\",\n  clearErrorOnChange = true,\n  initialValue,\n  initialError = null,\n  initialTouched = false,\n  onValueChange,\n  validateOnChange = false,\n  validateOnBlur = false,\n  validate,\n  resolveValidationError,\n  type = \"input\"\n}) {\n  const [valueState, setValueState] = useState(initialValue);\n  const valueRef = useRef(valueState);\n  const [key, setKey] = useState(0);\n  const [error, setError] = useState(initialError || null);\n  const touchedRef = useRef(initialTouched || false);\n  const [, setTouchedState] = useState(touchedRef.current);\n  const [isValidating, setIsValidating] = useState(false);\n  const errorResolver = useMemo(() => resolveValidationError || (err => err), [resolveValidationError]);\n  const setTouched = useCallback((val, {\n    updateState = mode === \"controlled\"\n  } = {}) => {\n    touchedRef.current = val;\n    updateState && setTouchedState(val);\n  }, []);\n  const setValue = useCallback((value, {\n    updateKey = mode === \"uncontrolled\",\n    updateState = mode === \"controlled\"\n  } = {}) => {\n    if (valueRef.current === value) {\n      return;\n    }\n    valueRef.current = value;\n    onValueChange?.(value);\n    if (clearErrorOnChange && error !== null) {\n      setError(null);\n    }\n    if (updateState) {\n      setValueState(value);\n    }\n    if (updateKey) {\n      setKey(currentKey => currentKey + 1);\n    }\n    if (validateOnChange) {\n      _validate();\n    }\n  }, [error, clearErrorOnChange]);\n  const reset = useCallback(() => {\n    setValue(initialValue);\n    setError(null);\n    setTouched(false);\n  }, [initialValue]);\n  const getValue = useCallback(() => valueRef.current, []);\n  const isTouched = useCallback(() => touchedRef.current, []);\n  const isDirty = useCallback(() => valueRef.current !== initialValue, [initialValue]);\n  const _validate = useCallback(async () => {\n    const validationResult = validate?.(valueRef.current);\n    if (validationResult instanceof Promise) {\n      setIsValidating(true);\n      try {\n        const result = await validationResult;\n        setIsValidating(false);\n        setError(result);\n      } catch (err) {\n        setIsValidating(false);\n        const resolvedError = errorResolver(err);\n        setError(resolvedError);\n        return resolvedError;\n      }\n    } else {\n      setError(validationResult);\n      return validationResult;\n    }\n  }, []);\n  const getInputProps = ({\n    withError = true,\n    withFocus = true\n  } = {}) => {\n    const onChange = getInputOnChange(val => setValue(val, {\n      updateKey: false\n    }));\n    const payload = {\n      onChange\n    };\n    if (withError) {\n      payload.error = error;\n    }\n    if (type === \"checkbox\") {\n      payload[mode === \"controlled\" ? \"checked\" : \"defaultChecked\"] = valueRef.current;\n    } else {\n      payload[mode === \"controlled\" ? \"value\" : \"defaultValue\"] = valueRef.current;\n    }\n    if (withFocus) {\n      payload.onFocus = () => {\n        setTouched(true);\n      };\n      payload.onBlur = () => {\n        if (shouldValidateOnChange(\"\", !!validateOnBlur)) {\n          _validate();\n        }\n      };\n    }\n    return payload;\n  };\n  const resetTouched = useCallback(() => setTouched(false), []);\n  return {\n    key,\n    getValue,\n    setValue,\n    reset,\n    getInputProps,\n    isValidating,\n    validate: _validate,\n    error,\n    setError,\n    isTouched,\n    isDirty,\n    resetTouched\n  };\n}\nexport { useField };","map":{"version":3,"names":["useField","mode","clearErrorOnChange","initialValue","initialError","initialTouched","onValueChange","validateOnChange","validateOnBlur","validate","resolveValidationError","type","valueState","setValueState","useState","valueRef","useRef","key","setKey","error","setError","touchedRef","setTouchedState","current","isValidating","setIsValidating","errorResolver","useMemo","err","setTouched","useCallback","val","updateState","setValue","value","updateKey","currentKey","_validate","reset","getValue","isTouched","isDirty","validationResult","Promise","result","resolvedError","getInputProps","withError","withFocus","onChange","getInputOnChange","payload","onFocus","onBlur","shouldValidateOnChange","resetTouched"],"sources":["C:\\Users\\Christina\\Desktop\\React\\FED-medical\\node_modules\\@mantine\\form\\src\\use-field.ts"],"sourcesContent":["import { useCallback, useMemo, useRef, useState } from 'react';\nimport { getInputOnChange } from './get-input-on-change';\nimport { FormMode, GetInputPropsType } from './types';\nimport { shouldValidateOnChange } from './validate';\n\ntype UseFieldErrorResolver = (error: unknown) => React.ReactNode;\n\nexport interface UseFieldInput<\n  T,\n  FieldType extends GetInputPropsType = 'input',\n  Mode extends FormMode = 'controlled',\n> {\n  /** Field mode, controlled by default */\n  mode?: Mode;\n\n  /** Initial field value */\n  initialValue: T;\n\n  /** Initial touched value */\n  initialTouched?: boolean;\n\n  /** Initial field error message */\n  initialError?: React.ReactNode;\n\n  /** Called with updated value when the field value changes */\n  onValueChange?: (value: T) => void;\n\n  /** Determines whether the field should be validated when value changes, false by default */\n  validateOnChange?: boolean;\n\n  /** Determines whether the field should be validated when it loses focus, false by default */\n  validateOnBlur?: boolean;\n\n  /** Determines whether the field should clear error message when value changes, true by default */\n  clearErrorOnChange?: boolean;\n\n  /** A function to validate field value, can be sync or async */\n  validate?: (value: T) => React.ReactNode | Promise<React.ReactNode>;\n\n  /** Field type, input by default */\n  type?: FieldType;\n\n  /** A function to resolve validation error from the result returned from validate function, should return react node */\n  resolveValidationError?: UseFieldErrorResolver;\n}\n\ninterface SetValueOptions {\n  updateState?: boolean;\n  updateKey?: boolean;\n}\n\ninterface GetInputPropsOptions {\n  withError?: boolean;\n  withFocus?: boolean;\n}\n\ninterface GetInputPropsSharedReturn {\n  error?: React.ReactNode;\n  onFocus?: () => void;\n  onBlur: () => void;\n  onChange: (value: any) => void;\n}\n\ntype GetInputPropsTypeValue<\n  T,\n  FieldType extends GetInputPropsType,\n  Mode extends FormMode,\n> = FieldType extends 'checkbox'\n  ? Mode extends 'controlled'\n    ? { checked: boolean }\n    : { defaultChecked: boolean }\n  : Mode extends 'controlled'\n    ? { value: T }\n    : { defaultValue: T };\n\ntype GetInputPropsReturnType<\n  T,\n  FieldType extends GetInputPropsType,\n  Mode extends FormMode,\n> = GetInputPropsSharedReturn & GetInputPropsTypeValue<T, FieldType, Mode>;\n\nexport interface UseFieldReturnType<\n  T,\n  FieldType extends GetInputPropsType = 'input',\n  Mode extends FormMode = 'controlled',\n> {\n  /** Returns props to pass to the input element */\n  getInputProps: (options?: GetInputPropsOptions) => GetInputPropsReturnType<T, FieldType, Mode>;\n\n  /** Returns current input value */\n  getValue: () => T;\n\n  /** Sets input value to the given value */\n  setValue: (value: T) => void;\n\n  /** Resets field value to initial state, sets touched state to false, sets error to null */\n  reset: () => void;\n\n  /** Validates current input value when called */\n  validate: () => Promise<React.ReactNode | void>;\n\n  /** Set to true when async validate function is called, stays true until the returned promise resolves */\n  isValidating: boolean;\n\n  /** Current error message */\n  error: React.ReactNode;\n\n  /** Sets error message to the given react node */\n  setError: (error: React.ReactNode) => void;\n\n  /** Returns true if the input has been focused at least once */\n  isTouched: () => boolean;\n\n  /** Returns true if input value is different from the initial value */\n  isDirty: () => boolean;\n\n  /** Resets touched state to false */\n  resetTouched: () => void;\n\n  /** Key that should be added to the input when mode is uncontrolled */\n  key: number;\n}\n\nexport function useField<\n  T,\n  Mode extends FormMode = 'controlled',\n  FieldType extends GetInputPropsType = 'input',\n>({\n  mode = 'controlled' as Mode,\n  clearErrorOnChange = true,\n  initialValue,\n  initialError = null,\n  initialTouched = false,\n  onValueChange,\n  validateOnChange = false,\n  validateOnBlur = false,\n  validate,\n  resolveValidationError,\n  type = 'input' as FieldType,\n}: UseFieldInput<T, FieldType, Mode>): UseFieldReturnType<T, FieldType, Mode> {\n  const [valueState, setValueState] = useState(initialValue);\n  const valueRef = useRef(valueState);\n  const [key, setKey] = useState(0);\n  const [error, setError] = useState<React.ReactNode>(initialError || null);\n  const touchedRef = useRef(initialTouched || false);\n  const [, setTouchedState] = useState(touchedRef.current);\n  const [isValidating, setIsValidating] = useState(false);\n  const errorResolver: UseFieldErrorResolver = useMemo(\n    () => resolveValidationError || ((err) => err as React.ReactNode),\n    [resolveValidationError]\n  );\n\n  const setTouched = useCallback((val: boolean, { updateState = mode === 'controlled' } = {}) => {\n    touchedRef.current = val;\n    updateState && setTouchedState(val);\n  }, []);\n\n  const setValue = useCallback(\n    (\n      value: T,\n      {\n        updateKey = mode === 'uncontrolled',\n        updateState = mode === 'controlled',\n      }: SetValueOptions = {}\n    ) => {\n      if (valueRef.current === value) {\n        return;\n      }\n\n      valueRef.current = value;\n\n      onValueChange?.(value);\n\n      if (clearErrorOnChange && error !== null) {\n        setError(null);\n      }\n\n      if (updateState) {\n        setValueState(value);\n      }\n\n      if (updateKey) {\n        setKey((currentKey) => currentKey + 1);\n      }\n\n      if (validateOnChange) {\n        _validate();\n      }\n    },\n    [error, clearErrorOnChange]\n  );\n\n  const reset = useCallback(() => {\n    setValue(initialValue);\n    setError(null);\n    setTouched(false);\n  }, [initialValue]);\n\n  const getValue = useCallback(() => valueRef.current, []);\n\n  const isTouched = useCallback(() => touchedRef.current, []);\n\n  const isDirty = useCallback(() => valueRef.current !== initialValue, [initialValue]);\n\n  const _validate = useCallback(async () => {\n    const validationResult = validate?.(valueRef.current);\n\n    if (validationResult instanceof Promise) {\n      setIsValidating(true);\n      try {\n        const result = await validationResult;\n        setIsValidating(false);\n        setError(result);\n      } catch (err) {\n        setIsValidating(false);\n        const resolvedError = errorResolver(err);\n        setError(resolvedError);\n        return resolvedError;\n      }\n    } else {\n      setError(validationResult);\n      return validationResult;\n    }\n  }, []);\n\n  const getInputProps = ({ withError = true, withFocus = true } = {}) => {\n    const onChange = getInputOnChange<T>((val) => setValue(val as any, { updateKey: false }));\n\n    const payload: any = { onChange };\n\n    if (withError) {\n      payload.error = error;\n    }\n\n    if (type === 'checkbox') {\n      payload[mode === 'controlled' ? 'checked' : 'defaultChecked'] = valueRef.current;\n    } else {\n      payload[mode === 'controlled' ? 'value' : 'defaultValue'] = valueRef.current;\n    }\n\n    if (withFocus) {\n      payload.onFocus = () => {\n        setTouched(true);\n      };\n\n      payload.onBlur = () => {\n        if (shouldValidateOnChange('', !!validateOnBlur)) {\n          _validate();\n        }\n      };\n    }\n\n    return payload;\n  };\n\n  const resetTouched = useCallback(() => setTouched(false), []);\n\n  return {\n    key,\n    getValue,\n    setValue,\n    reset,\n    getInputProps,\n\n    isValidating,\n    validate: _validate,\n\n    error,\n    setError,\n\n    isTouched,\n    isDirty,\n    resetTouched,\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}